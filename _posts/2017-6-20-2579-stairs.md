---
layout: post
title: "BOJ 2579 계단 오르기"
description: "Dynamic Programming"
tags:
  - "algorithm"
  - "dynamic programming"
comments: true
share: true
date: 2017-6-20
---


# 계단 밟기

규칙은 3가지다.

1. 계단은 한 번에 한 계단 or 두 계단씩 오를 수 있다. 즉, 한 계단을 밟고 이어서 다음 or 다다음 계단에 오를 수 있다.
2. 연속된 세 개의 계단은 밟을 수 없다.
3. 마지막 계단은 무조건 밟는다.

이런 방식으로 계단을 오를 때 최대 값을 가져야한다.

일단 DP 문제다.
3번 규칙을 보면, 마지막 계단을 무조건 밟아야한다.

작은 문제 부터 풀어보자.

1. 계단이 2개 있는 경우(`dp[2]`)

당연히 2개 다 밟아야 한다.


2. 계단 3개(`dp[3]`)

3번 규칙을 적용시켜보면 2가지 경우의 수가 나온다.

- 마지막 계단 전의 계단 밟기  : `a[3] + a[2]`
- 마지막 계단 전전의 계단 밟기 : `a[3] + a[1]`

마지막 계단 전의 계단 밟기에서 `a[2]`가 `dp[2]`가 될 수 없다. `dp[2]`가 `a[1]`을 포함하였다면 연속 3개가 될 수 있기 때문이다.

3. 계단 4개(`dp[4]`)

동일하다.

- 마지막 계단 전 : `a[4] + a[3] + a[1](dp[1])`
- 마지막 계단 전전의 계단 밟기 : `a[4] + dp[2]`

dp로 표현된 이유는 우리가 앞에서 이미 1번째 or 2번째까지의 최대값을 계산 했기 때문이다.


점화식을 구해보자

- 마지막 계단 전 : `a[n] + a[n-1] + dp[n-3]`
- 마지막 계단 전전 : `a[n] + dp[n-2]`

```C
dp[n] = max(a[n] + a[n-1] + dp[n-3], a[n] + dp[n-2]);
```

큰 문제를 작게 풀려고 하면 잘 풀리는 문제다.
