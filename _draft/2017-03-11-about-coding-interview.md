---
  layout: post
  title: 코딩 인터뷰 완전 분석 정리 (1)
  description: 기술 문제 대비 해보자.
  tags:
    - interview
  comments: true
  share: true
  date: 2017-3-11
---


# 기술 문제 대비

문제와 답을 읽기만 하는 것은 대수학 공부를 하는 것과 같다. 문제를 푸는 훈련을 해야한다. 답을 외우는 것은 도움이 되지 않는다.

## 문제 대비 훈련법

1. 문제를 풀 때 공간과 시간효율에 대해서 반드시 생각하자

	공간 효율을 희생해서 시간 효율을 높일 수 있는지, 아니면 반대로 할 수 있는지 자문하자.


2. 알고리즘 코드를 **종이**에 적자.

	면접을 보는 동안

	- 문법 강조기능
	- 코드완성
	- 컴파일링 기능

	이 갖춰진 도구의 도움을 받을 수 없다. 종이에 코딩하면서 같은 상황에 대비하자.


3. 코드를 테스트하라.

	역시 종이 위에. 기본 조건, 오류 발생 조건 등을 전부 테스트해라. 마찬가지로 면접 중에 그렇게 해야한다.


4. 종이에 적은 코드를 그대로 컴퓨터로 옮겨라.

	종이에 적는 과정에서 많은 실수가 발생한다.

	실수 목록들을 만들고, 실제 면접장에서 그런 실수를 저지르지 않도록 하자.


## 알아야 할 것들

이진 트리 균형을 맞추는 방법 중 특정한 것을 묻거나, 기타 복잡한 알고리즘에 대해 묻지 않는다. ~~그들도 잘 기억하지 못한다.~~

여러분에게 기대하는 것은 **기본기**다.

### 자료구조

- 연결 리스트
- 이진 트리
- 트라이
- 스택
- 큐
- vector/ArrayList
- 해시테이블

### 알고리즘

- BFS
- DFS
- Binary Search
- merge sort
- quick sort
- about tree insertion / search 등등

### 개념

- 비트 조작
- singleton design pattern
- factory design pattern
- memory (Stack vs Heap)
- Recursion
- O 표기법


이 주제들에 대해 사용법, 구현법, 공간/시간 복잡도에 대해 알아두자.

자료구조와 알고리즘의 경우, 아무것도 없는 상태에서 밑바닥부터 구현이 가능하도록 연습하라.

`구현 문제`, `주어진 코드를 변형하라는 문제` 등이 나올 수 있다.


## 2급수표

데이터 저장에 필요한 공간 계산시 편리하게 쓰인다.

|x|2^x|근사값|메모리 요구량(바이트)|

이 테이블이 있으면 32비트 정수를 불린 값에 대응시키는 해시 테이블이

한 대 컴퓨터 메모리를 얼마나 잡아 먹을지 쉽게 계산 가능하다.

웹 기반 사업을 하는 회사와 전화 면접 하는 경우, 보이는 곳에 붙여 놓자.


## C++, Java 아니면 다른 프밍 언어의 세부사항을 알고 있어야 할까?

케바케다. 필자는 이런 질문을 좋아하지 않는다.

언어의 주된 개념은 기억해야 하지만, 정작 공을 들어야 하는 부분은 자료구조와 알고리즘이다.


## 기술 문제 대처 요령

어려운 문제를 만나도 당황하지 말자. ~~필자의 경험에 따르면 120명 이상의 지원자 가운데 바로 답을 내놓은 사람은 10명에 불과하다.~~

어떻게 풀 것인지 이야기하는 것으로 시작하라.

어떻게 문제를 공략해 나갈 것인지 면접관에게 보여주어,

막혀 쩔쩔매고 있다는 인상을 주지 말자.

면접관이 '끝' 이라고 하기 전까지 끝난게 아니다.

무슨 말이냐면, 알고리즘을 생각해 낼 때,

	- 그에 수반되는 문제
	- 버그를 찾아 내기

를 해라.

### 기술 문제를 푸는 다섯 단계

1. 면접관에게 문제의 모호한 부분에 대해 묻는다.
2. 알고리즘을 설계한다.
3. 가상 코드를 먼저 작성하라. 실제 코드는 마지막에 작성할 거라고 말한다.
4. 적당한 속도로 코드 작성하라
5. 코드를 테스트하고, 주의 깊게 교정하라


#### 1단계: 질문 던지기

기술 문제는 생각보다 모호한 부분이 많다. 모호한 부분은 반드시 질문하자.

그러다 보면 생각 한 것 보다 아주 다른, 그러나 때로 좀 더 쉬운 문제를 풀어야 한다는 사실을 알 수 있다.

사실, 많은 면접관은 여러분이 좋은 질문을 던질 능력이 있는지도 테스트한다.

좋은 질문이란

	- `자료형`은 무엇인가요?
	- 데이터가 얼마나 많은 가요?
	- 어떤 가정을 해야 하나요?

> 리스트를 정렬하는 알고리즘 문제를 받았다고 해보자.
>
질문 : 어떤 리스트인가요? 배열인가요? 연결 리스트인가요?
답 : 배열입니다.
질문 : 배열에는 어떤 데이터가 들어가나요? 수? 문자? 문자열?
답 : 수입니다.
질문 : 정수들인가요?
답 : 그렇습니다.
질문 : 이 수들은 어떤 수인가요? 식별자 혹은 어떤 값인가요?
답 : 고객의 나이 입니다.
질문 : 고객의 수는?
답 : 백만명 정도 입니다.


이제 처음과는 다른 문제가 되었다.

0에서 130까지의 (아무리 나이가 많더라도 이보다 많지는 않을 것이다.) 범위에 속하는 정수 백만 개를 정렬하는 문제가 되었다.

어떻게 풀까? 길이가 130인 정수 배열 생성하여 수가 나올 때마다 그에 해당하는 배열 원소의 값을 하나씩 증가 시키면 된다.


#### 2단계 : 알고리즘 설계

알고리즘 설계는 까다롭다. 다음 `알고리즘 설계의 다섯가지 접근법`은 도움이 된다.

- 시간과 공간 복잡도는?
- 데이터가 많아지면 어떻게 될까?
- 내 설계가 다른 이슈들을 파생시키지 않는가? 일례로, 변형 이진 탐색 트리 만들었다면, 여러분의 설계가 기존의 삽입, 탐색, 삭제 시간에 영향을 미치지 않는가?
- 다른 이슈나 한계점이 있다면 적절한 타협안을 만들었나? 그 타협안이 최적으로 동작하지 않는 시나리오는?
- 면접관이 데이터의 특징을 명시했다면, 그 특징을 활용하였는가?(나이 혹은 정렬된 상태) 면접관이 그런 정보를 줄 때는 이유가 있기 마련이다.

처음에는 brute-force 알고지믕을 내놓아도 된다.

그 다음 최적화 시키면서 나가면 된다.

가능한 최적의 답안을 내야하지만, 처음부터 완벽할 필요는 없다.


#### 3단계 : 가상코드

가상 코드는 실수를 줄이는데 도움이 된다.


#### 4단계 : 코드

코드를 급히 작성할 필요가 없다.

- 자료구조를 활용하라 : 관련성이 있다면, 좋은 자료구조를 선택해 활용하거나 스스로 정의하여 사용하자. '사람'을 나타내는 자료구조를 정의할 수 있는지 고려해 보자. 이렇게 하면 여러분이 올바른 `객체 지향 설계`에 신경 쓴다는 인상을 받을 것이다.


#### 5단계 : 테스트

- 극단적인 경우 : 0, 음수, null, 최댓값, 최솟값
- 사용자 실수 : 만일 사용자가 null or 음수값을 준다면?
- 일반적인 경우들 : 일반적인 경우에 대해 테스트하자.

코딩이 끝난 다음이 아닌, **코딩 도중에 테스트를 해라**

**실수를 발견했다면 교정 작업에 들어가기 전에 `왜` 그 버그가 발생했는지 깊이 생각해라.**

되는대로 고치고 보는 사람이라는 인상을 주면 안된다.

> 가령 여러분이 만든 함수가 어떤 값에 대해 true 대신 false를 반환하는 것을 발견했다고 치자.
반환값을 무작정 뒤집으면 그 특정한 경우 오류가 사라지겠지만, 결국 다른 새로운 문제 발생을 피할 수 없다.



## 알고리즘 설계의 다섯 가지 접근법

더 많은 문제로 훈련할수록, 어떤 접근법이 유용할지 판단하기 쉬워진다.

아래의 다섯 접근법은 뒤섞어 사용할 수 있다.

`단순화 & 일반화`를 적용하고, `패턴 매칭`을 시도할 수 있다.


### 접근법 1 : 예증

특정한 사례를 나열한다.

그 다음 일반적 규칙을 유도할 수 있는지 본다.

> 예제: 시간이 주어졌을 떄, 시침과 분침 사이의 각도를 구하라.
3:27과 같은 사례뿌터 시작해보자. 시침과 분침을 적정한 위치에 두고 그림을 그릴 수 있다.
몇가지 사례를 보면 아래와 같은 규칙을 이끌어 낼 수 있다.
- 분침과 12사이의 각도는 360 * m/60
- 시침과 12사이의 각도는 360 * (h%12)/12 + 360 * (m/60) * (1/12)이다.
답은 (30h-5.5m) % 360 임을 알 수있다.


### 2: 패턴 매칭

풀어야 할 알고리즘이 어떤 문제와 유사했는지 살핀다.

그리고 그 문제의 답을 수정하여 지금 풀어야 하는 문제에 적용할 알고리즘을 개발한다.

> 예제: 정렬된 배열을 회전시켜 3 4 5 6 7 1 2와 같은 배열을 얻었다.
배열안에 중복된 값은 없다. 이 배열 내에서 최솟값을 구하는 방법은?
- 배열 내의 최솟값 찾기
- 배열 내의 특정 원소 찾기(가령, 이진 탐색)

#### 접근법

배열 내에서 최솟값 원소를 찾는 것은 흥미로울 게 없는 알고리즘이다.

또한, 배열이 정렬되어 있다는 정보를 이용해 봐도 그렇다.

하지만 이진 탐색 기법은 유용하다.

배열이 정렬되어 있다는 것, 하지만 회전된 상태라는 것

그러니 오름차순으로 정렬하다 초기화하고, 다시 전진 시켜야 한다.

최솟값 원소는 `초기화된` 지점에 있다.

배열의 중간 원소 (MID)와 마지막 원소 (RIGHT)를 비교해 보면 (6과 2) 초기화 지점이 우측이라는 것을 알 수 있다.

MID > RIGHT이기 때문이다. .. 중략 .. 이진 탐색 방식을 생각하면 유추가 가능하다.



### 3: 단순화와 일반화

다단계 접근법으로 구현하자.

자료형이나 데이터 양과 같은 제약 조건을 변경하자.

이렇게 하면 문제를 `단순화` 하는데 도움이 된다.

알고리즘이 구해지면, 보다 복잡한 형태로 다듬어 간다.

>예제 : 인질범이 즐겨 사용하는 몸값 쪽지는 잡지에서 단어를 오려 새로운 문장으로 조합해 내는 것이다.
잡지가 주어졌을 때, 그 잡지에서 특정한 몸값 쪽지로 만들6
