# react

## react 주요 특징

Virtual DOM을 사용하여 상태의 변화에 따라 선택적으로 UI를 렌더링한다.
즉, 최소한의 DOM 처리로 컴포넌트를 update한다. 

### 어떻게?

일단 DOM의 문제를 알아보자.
페북과 같은 대규모 웹앱에서 데이터를 표현하는 요소의 개수는 백단위다. 
DOM에서 직접 접근하여 변경하면 성능 이슈 발생한다.
데이터 하나 바꼈는데 매번 reflow를 하면 성능이 저하된다. 
왜냐하면 html,css를 재연산 하여 reflow와 repaint라는 렌더링 과정을 다시 거치기 때문이다.

여기서 기존의 해결책은 reflow 횟수를 줄이는 것이다.

하지만 만약 DOM 작업을 가상화 하여 미리 처리하고, 다음에 한꺼번에 적용할 수 있다면?

---

# proxy

## 프록시 서버

클라와 서버 사이에 거쳐 가는 중개자

- proxy : 같은 프로토콜간 연결
- gateway : 서로 다른 프로토콜을 연결

### 왜 사용할까?

- 어린이 필터
- 웹캐시 : CDN과 같은 팜영역에 데이터 캐싱?
- 대리 프락시 : 리버스 프락시 등으로 분산네트워크 환경 구축
- 트랜스 코더 : 파일 이미지 같이 용량 큰 데이터를 작은 사이즈로 변하여 제공

# 웹 캐시

웹 캐시는 자주 쓰이는 문서의 사본을 자동 보관하는 HTTP 장치

## 이점

- **불필요한 데이터 전송을 줄인다.** 그래서 네트워크 요금으로 인한 비용 감소시킨다.
- 네트워크 병목을 줄여준다. 대역폭을 늘리지 않고도 페이지를 빨리 불러온다. 
- 원 서버에 대한 요청을 줄여준다. 서버 부하를 줄이며 더 빨리 응답 가능하다.


## HTTP 헤더

**Last-Modified** : `If-Modified-SInce`, `If-UnModified-Since`
**ETag based** : `If-Match`, `If-None-Match`

사본을 신선하게 유지해보자.

```
Expires: Fri, 04, Jul 2002, 05:00:00 GMT
Cache-Control: max-age=600000
```

캐시된 문서가 만료가 되었다 = 문서가 변경된게 아닌 문서가 변경 됐을 수도 있으니까 나(서버)한테 확인해.
재검사 요청시, `Last-Modifed` 헤더를 사용하여 효율적 처리

- 변경사항 없으면 `304 Not Modifed` 전송
- 변경 사항 있으면 `200 OK`로 변경사항과 함께 전송

------------------------------------------------------------------------------------------
------------------------------------------------------------------------------------------

# 웹성능 최적화

1. 요청 줄이기
  - 캐시 (다운로드 안하기)
  - CSS Sprite 사용 (요청 하나로)

2. 용량 줄이기
  - CSS 통합 (요청 하나로), minify
  - 이미지 형식에 따라 색데이터 압축방식이 다르다. 이것에 맞는 이미지를 사용하여 용량 최적화.
  - 불필요한 이미지 메타데이터 제거
  - gzip 압축 사용 defalte도 있지만 대부분의 브라우저가 gzip 지원
    - html,css, js와 같은 파일 압축
  - 쿠키가 없는 도메인 요청
    - 쿠키가 필요없는 정적 데이터 html, css, js, 이미지에 대해 쿠키 없이 요청을 보내서 용량을 줄인다.

3. 렌더링 성능 최적화 (사용자에게 체감 성능 높이고, 초기 렌더링 시간 줄이기)
  - CSS는 위로 : 왜냐면 렌더트리를 빨리 만들어야 리페인트 리플로우 하는데, 렌더트리 만드는 조건은 DOM + CSSOM이니까.
  - Lazy Loading : 당장 필요하지 않은 JS 및 image를 렌더링 완료 후 처리(스크롤 내려서 그 위치가 화면에 보일 때 로드하기)
  - iFrame 사용 지양 : iFrame 내부 page처리 완료시까지 렌더링 중지

4. 기타
- 404 최대한 줄이기 : HTTP 요청은 비용이 발생하는데 불필요한 비용 발생한다.
- 쿠키 
  - 다른 서브도메인들이 영향을 받지 않도록 적절한 도메인 수준(level)에서 쿠키설정을 주의해라 (상위도메인 등록 ㄴㄴ해)
  - 만료 날짜 꼭 설정하기
- 빈 이미지 src 줄이기
- CDN 사용 : 분산된 서버에 컨텐츠 올려서 받기 CDN은 그리고 알아서 회선에 따라 사용자 위치에 따라 가장 빠르게 받을 수 있는 곳에서 컨텐츠 제공


# 1. 요청 줄이기

## 이미지

인터레이스드 PNG : 눈꼽만큼이라도 로딩되면 보여주겠다.


## http 캐시

캐시는 http 성능 최적화를 위해 사용된다. 성능 최적화 방법 중 하나는 데이터를 다운받지 않는 방법이 있다.
데이터를 캐싱해뒀다가 데이터 만료기간이 지났다면 서버에 데이터 변경 여부만 물어서 다운로드를 최소화 하는 방법 중 하나다.

1. ETag를 이용한 캐싱 < - > not modifed (304)
2. expires < - > if-modifed-since


1. ETag

한 개의 정적 데이터를 요청한다고 해보자.
이 때 서버는 클라이언트에 이 데이터를 주며 캐시하기 원한다.
그 방법으로는 http 헤더를 이용한다.
ETag에 고유한 Id값을 전달한다. 그리고 Cache-Control에 key-value로 max-age=캐싱되는시간(초)을 http헤더에 포함한다.

브라우저는 데이터를 받고, 헤더를 확인하여 도메인과 이미지 데이터 캐시 컨트롤의 값 Etag를 함께 저장한다.

그리고 브라우저가 동일한 도메인으로 요청시 max-age 시간이 지난 후에 요청을 하면 데이터가 바꼈는지 확인하기 위해,
ETag와 함께 GET요청을 보낸다.

서버에서는 데이터가 변경되지 않았다면 `304 not modified` 상태코드와 함께
기존의 E-Tag와 새로운 만료기간을 보내준다.

만약 데이터가 바꼈다면 새로운 캐싱 정보를 남기기 위해 새로 만든 E-Tag와 만료기간을 보내준다.

2. expires
GMT시간을 사용한다. 서버와 클라이언트의 시간을 맞추어서 이용해야만 하는 문제점이 발생한다.
cache-control의 max-age 속성을 이용하면 극복 가능하지만 cache-control은 HTTP 1.0이 지원하지 못하므로 
cache-control의 max-age와 Expires를 모두 활용하는게 좋다. 둘 다 있을경우 cache-control이 우선한다.

# 2. 용량 줄이기



---


# Http란

WWW 상에서 정보를 주고받을 수 있는 프로토콜이다.
HTTP는 HTML 문서와 같은 리소스들을 가져올 수 있도록 해주는 무상태 프로토콜(protocol)이다.


----

# 쿠키와 세션

쿠키는 사용자의 상태 및 정보를 클라이언트에 저장한다.
쿠키 만료 기간을 헤더에 붙여서 응답하기 때문에 브라우저를 종료해도 남아있다.

세션은 사용자의 상태 및 정보를 서버에 저장한다.
클라이언트는 session_id를 저장한다. 
쿠키 만료기간이 없다. 브라우저 종료하면 세션도 사라진다.]


---

# React

React는 페이스북에서 만든 UI라이브러리다.
모든 UI를 컴포넌트 단위로 만들어 재사용성 높인다.
기존 DOM API의 느린 단점을 극복하기 위해 Virtual DOM 사용.

기존 DOM은 렌더링 과정을 거친다.
예를 들어 페북같은 대규모 웹어플리케이션에서 데이터를 표현하는 요소의 개수가 100개가 넘는다.
만약 첫 페이지 로드시 100개의 데이터를 반영하기 위해 DOM API로 직접 접근하여 변경하면 성능이슈 발생
매번 리렌더링을 하게 된다.

페북에서는 이것의 해결책으로 DOM 작업을 가상화 하여 미리 처리하고, 한꺼번에 적용할 수 있는 해결책을 내놓았다. 
즉 30개의 노드에 데이터를 반영하기 위해 30번의 리렌더링을 거치는데 이 횟수를 1번으로 줄이겠다는 것이다.

먼저 Virtual DOM은 리액트 라이브러리가 만든 offline DOM tree에 적용한다. 이 DOM Tree는 노드를 수정해도 렌더링이 없다.
그래서 컴포넌트들에 대한 일련의 연산솨정이 끝나면 그 때 실제 DOM에 던진다. 리렌더링 규모는 크지만 횟수는 1번으로 줄어든다.

물론 Virtual DOM없이 순수 JS로 모았다가 할 수 있다. 하지만 기존 값중 어떤게 변했는지 일일히 알아야 하는데.. 만야 이걸 모르면 수정할 필요가 없는 DOM tree도 없데이트 하게된다. 여튼 이러한 과정을 Virtual DOM이 자동화 해준다.

그럼 무조건 React가 빠른가? 그것은 아니다.
리덕스 개발자가 한 말이 있는데 유지보수 가능한 어플리케이션을 만드는 것을 도와주고 대부분의 경우 충분히 빠르다 라고 한다.

결론적으로 최적화 작업을 직접 했을 때 VS 리액트로 했을 때 전자가 빠를 수도 있다. 하지만 대규모 웹어플리케이션에서는 자동화 해주는 리액트를 사용하여 생산성을 배로 높일 수 있다.

----

# Redux

기존 MVC는 그림으로 그리면 이렇다.

웹어플리케이션이 커질수록 어떤 모델이 뷰를 건드리는지 알아보기 힘들다.

리액트에서는 이런식으로 데이터 교류를 한다. 데이터흐름이 단방향이라 올라갔다 내려갔다한다.

그래서 Redux라는게 나왔다.

Store라는 중간교류자를 통해 교류한다.

dispatch와 subscribe라는 Redux 메서드를 사용하여 데이터 교류가 원활해졌다.


# 객체지향

현실에 있는 사물을 인지하는 방식대로 프로그래밍하는 것.
객체지향에서 객체는 "세상에 존재하는 모든 것은 고유한 객체다"라는 뜻이다
이 때 객체는 어떤 속성과 행위를 갖는다.
프로그래밍에서 객체의 어떤 속성은 프로퍼티로 행위를 메서드로 정의한다.

그래서 클래스란? 분류에 대한 개념을 정의. 말 그대로 객체는 실체
클래스를 기반으로 실체화 된것을 인스턴스라고 한다.

객체지향에 4가지 특징 있다.

## 추상화
- 객체의 모든 특성 및 행위를 정의 하지 못한다. 
- 그래서 객체의 공통된 특성 및 필요한 특성을 선별하여 정의한다. 

## 상속
- 상위 클래스의 프로퍼티나 메서드를 상속하여 재사용성을 높이는 것.

## 다형성

- 오버로딩 : 같은 메서드 이름이지만 다른 인자 목록으로 다수의 메서드 **중복 정의** 가능하다.

- 오버라이딩 : 부모에게서 상속 받은 메서드를 동일 이름 동일 인자로 자식이 재정의

## 캡슐화
- **객체에 관한 속성을 묶어 안보이게 하는것**
- 보안의 의미도 있지만 사용하는 사람이 내부 로직을 알지 못해도 메서드와 같은 것들을 사용하도록 한다. 그리고 이러한 메서드들을 묶어놓는 것.




---
# 인성

- 떨어져도 괜찮다. 이 순간을 하나의 경험으로 즐기고. 실패한 경험이라면 그 경험을 통해 내 단점을 더 정확히 볼 수 있는 소중한 기회다.

- 티몬에서 구체적으로 하고싶은 것. 티몬이라는 서비스에 맞는 UI 라이브러리를 개발해보고 싶다. 최종적으로는 내 이름을 걸고 프론트엔드 개발에 도움이 되는 라이브러리를 만들어보고 싶다는

- **질문에 대한 추가 질문하기**
- 문제에 대한 풀이법 제시. 이외에 다른 풀이법이 있다면 여쭤봐도 될까요?

- 제 면접이 CTO님이 보시기에 어땠나요? 제가 어떤 부분을 더 보강하면 좋을까요? 

- 모르는 건 솔직히 모른다고

- 저는 웹 성능 최적화에 관심이 많습니다. 티몬과 같은 이 커머스 서비스에서 다양한 고객층이 있을 거라 생각한다.


문자열 뒤집기
```C
string ReverseString(const string src, int len)
{
      string reverse;
 
      for(int i=0;i<len;i++)
            reverse+=src.substr(len-i-1,1);
 
      return reverse;
}
```