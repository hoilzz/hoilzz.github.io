{"data":{"site":{"siteMetadata":{"title":"hoilzz","author":"hoilzz","siteUrl":"","comment":{"disqusShortName":"","utterances":"hoilzz/hoilzz-blog"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"552629d5-3fff-5840-8f28-7987717bfc99","excerpt":"급하면 2번 부터 보자. 1. Event dispatch and DOM event flow 과  에 대해 알아보자. Application은  를 통해 이벤트 objects를 전파한다. 그리고 event object는 DOM event flow로 결정된 DOM tree를 통해 propogate한다. Event objects는  으로 전파된다. 하지만 전파되기 전에, event object의  가 먼저 결정되어야 한다. 는 이벤트가 통과하는 현재 이벤트 타겟들의 ordered list…","html":"<p>급하면 2번 부터 보자.</p>\n<h2 id=\"1-event-dispatch-and-dom-event-flow\"><a href=\"#1-event-dispatch-and-dom-event-flow\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Event dispatch and DOM event flow</h2>\n<p><code class=\"language-text\">event 전파 과정</code>과 <code class=\"language-text\">DOM tree를 통한 이벤트 propagate 방식</code>에 대해 알아보자. Application은 <code class=\"language-text\">dispatchEvent()</code>를 통해 이벤트 objects를 전파한다. 그리고 event object는 DOM event flow로 결정된 DOM tree를 통해 propogate한다.</p>\n<p><img src=\"https://www.w3.org/TR/DOM-Level-3-Events/images/eventflow.svg\" alt=\"W3C 이벤트 전파 과정\"></p>\n<p>Event objects는 <code class=\"language-text\">event target</code>으로 전파된다. 하지만 전파되기 전에, event object의 <code class=\"language-text\">propagation path</code>가 먼저 결정되어야 한다.</p>\n<p><code class=\"language-text\">propogation path</code>는 이벤트가 통과하는 현재 이벤트 타겟들의 ordered list다. propagation path는 document의 계층 트리 구조의 영향을 받는다.(위 그림처럼) 리스트의 마지막 item은 <code class=\"language-text\">event target</code>이다. 그리고 리스트의 이전 아이템들은 <code class=\"language-text\">target</code>의 조상을 가리킨다.</p>\n<p><code class=\"language-text\">propagation path</code>가 결정되면, <strong>이벤트 오브젝트는 1개 이상의 event 경로를 통과</strong>한다. 3가지 이벤트 경로가 있다.</p>\n<ol>\n<li>capture phase</li>\n<li>target phase</li>\n<li>bubble phase</li>\n</ol>\n<p>이벤트 객체는 이 경로를 다음 설명처럼 완료한다. 만약 경로를 지원하지 않는다거나, 이벤트 객체 propagation이 멈추면 skip한다. 예를 들어 <code class=\"language-text\">bubble</code> attribute가 false라면, bubble phase는 skip된다. 만약 <code class=\"language-text\">stopPropagation()</code>이 <code class=\"language-text\">dispatch</code>보다 앞에 호출된다면, 모든 phases는 skip된다.</p>\n<p>capture phase\n: event object는 window 에서 target’ parent로 target의 조상을 통해 propogate한다. (event는 엘리먼트로 내려간다.)</p>\n<p>target phase\n: event 객체는 event 객체의 target에 도착한다. event가 버블링 false로 명시하면, 이벤트 객체는 phase 완료 후 중지한다. (이벤트가 타겟 엘리먼트에 도착했다.)</p>\n<p>bubble phase\n: event 객체는 target의 조상을 통해 (capture와)반대로 propagate한다. target의 부모에서 시작하여 Window에서 끝이 난다. (이벤트는 위로 버블링 up 한다.)</p>\n<h2 id=\"2-capture-and-bubble\"><a href=\"#2-capture-and-bubble\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. Capture and Bubble</h2>\n<p class=\"codepen\" data-height=\"265\" data-theme-id=\"dark\" data-default-tab=\"js,result\" data-user=\"cooking\" data-slug-hash=\"wdQbJq\" style=\"height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;\" data-pen-title=\"wdQbJq\">\n  <span>See the Pen <a href=\"https://codepen.io/cooking/pen/wdQbJq/\">\n  wdQbJq</a> by cooking (<a href=\"https://codepen.io/cooking\">@cooking</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.</span>\n</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n<p><code class=\"language-text\">&lt;em&gt;&lt;/em&gt;</code> 안의 내용을 클릭했는데 어떻게 div가 실행될까?</p>\n<h3 id=\"bubbling\"><a href=\"#bubbling\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Bubbling</h3>\n<p>Bubbling은</p>\n<p>이벤트가 엘리먼트에서 일어났을 때, 먼저 이벤트가 일어난곳의 핸들러를 실행한다. 그 다음엔 해당 엘리먼트의 부모, 그 부모의 부모.. 조상까지 DOM 트리를 타고 올라간다.</p>\n<p>각각 클릭 이벤트가 바인딩 된 중첩된 엘리먼트 <code class=\"language-text\">form &gt; div &gt; p</code>를 보자.</p>\n<p class=\"codepen\" data-height=\"265\" data-theme-id=\"dark\" data-default-tab=\"js,result\" data-user=\"cooking\" data-slug-hash=\"wdQbJq\" style=\"height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;\" data-pen-title=\"wdQbJq\">\n  <span>See the Pen <a href=\"https://codepen.io/cooking/pen/wdQbJq/\">\n  wdQbJq</a> by cooking (<a href=\"https://codepen.io/cooking\">@cooking</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.</span>\n</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n<p><code class=\"language-text\">&lt;p&gt;</code>를 클릭하면 다음 순서대로 실행된다.</p>\n<ol>\n<li><code class=\"language-text\">p</code></li>\n<li><code class=\"language-text\">&lt;div&gt;</code></li>\n<li><code class=\"language-text\">&lt;form&gt;</code></li>\n<li><code class=\"language-text\">document</code> object까지 쭉 올라간다.</li>\n</ol>\n<p>그래서 p,div,form 순으로 alert 메시지를 볼 수 있다. 그 이외의 부모 엘리먼트에 대한 alert가 안보이는 이유는 이벤트에 대한 핸들러가 없기 때문이다.</p>\n<p>이와 같이 내부 엘리먼트(이벤트 타겟)에서 부모를 통해 DOM tree를 올라가는 과정을 <code class=\"language-text\">bubbling</code>이라고 한다.</p>\n<blockquote>\n<p>거의 모든 이벤트는 버블링한다.\n<code class=\"language-text\">blur</code>이벤트는 버블링 안하는데 걍 문서 참고하면서 사용하자.</p>\n</blockquote>\n<h3 id=\"eventtarget\"><a href=\"#eventtarget\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>event.target</h3>\n<p>부모 엘리먼트의 핸들러에서 이벤트가 실제로 일어난 곳에 대한 정보를 얻을 수 있다.</p>\n<p><strong>이벤트를 발생시킨 깊게 중첩된 엘리먼트는 <code class=\"language-text\">target</code> element라고 한다. 이것은 <code class=\"language-text\">event.target</code>으로 접근가능하다</strong></p>\n<p><code class=\"language-text\">event.target</code>은 이벤트를 이니셜라이징한 <code class=\"language-text\">target</code>이고 그것은 버블링 과정동안 <code class=\"language-text\">불변</code>한다.</p>\n<p>event handler에서 <code class=\"language-text\">this</code>는 <code class=\"language-text\">current</code> element다. 즉, 현재 핸들러를 실행하는 엘릴먼트다.</p>\n<p>다음 코드는 <code class=\"language-text\">event.target</code>과 <code class=\"language-text\">this</code>를 알려주는 예제다.</p>\n<p>가장 바깥쪽의 <code class=\"language-text\">form</code> 에 click event에 대한 핸들러를 바인딩 했다.</p>\n<p class=\"codepen\" data-height=\"265\" data-theme-id=\"dark\" data-default-tab=\"js,result\" data-user=\"cooking\" data-slug-hash=\"wdQbJq\" style=\"height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid black; margin: 1em 0; padding: 1em;\" data-pen-title=\"wdQbJq\">\n  <span>See the Pen <a href=\"https://codepen.io/cooking/pen/wdQbJq/\">\n  wdQbJq</a> by cooking (<a href=\"https://codepen.io/cooking\">@cooking</a>)\n  on <a href=\"https://codepen.io\">CodePen</a>.</span>\n</p>\n<script async src=\"https://static.codepen.io/assets/embed/ei.js\"></script>\n<h3 id=\"stop-bubbling\"><a href=\"#stop-bubbling\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>stop bubbling</h3>\n<p>bubbling event는 target element에서 부모의 부모로 계속 올라간다.\n일반적으로 <code class=\"language-text\">&lt;html&gt;</code> 위쪽 까지 올라가고, 그리고나서 <code class=\"language-text\">document</code> object로 이동하고 일부 이벤트는 <code class=\"language-text\">window</code>까지 도달하여 모든 핸들러를 호출한다.</p>\n<p>이 때, <code class=\"language-text\">event.stopPropagation()</code>을 통해 버블링을 중지할 수 있다.</p>\n<blockquote>\n<p>필요한게 아니면 bubbling stop 하지말자.\n버블링은 편리하다. 가끔 <code class=\"language-text\">stopPropogation()</code> 은 숨겨진 문제를 만든다.\n예를 들어:</p>\n</blockquote>\n<ol>\n<li>중첩 메뉴 만들었다. 각 서브메뉴는 메뉴 아이템마다 클릭을 처리해야한다 그리고 <code class=\"language-text\">stopPropogation</code>을 호출해서 outer part에 trigger되지 않도록 한다.</li>\n<li>나중에 유저의 행위를 추적하기 위해 전체 윈도우 내부의 클릭 이벤트를 잡기로 결정했다. 가끔 counter만들 때 이렇게 만든다. <code class=\"language-text\">document.addEventListener(&#39;click&#39;..)</code></li>\n<li>counter는 <code class=\"language-text\">stopPropogation</code>이 멈춘 지역에선 작동하지 않는다.</li>\n</ol>\n<p><code class=\"language-text\">Capture</code>는</p>\n<ul>\n<li>이벤트 발생시, 해당 이벤트를 Capture하기 위해 이벤트가 발생한 요소를 포함하는 <strong>부모 HTML로부터 이벤트의 근원지인 자식 요소까지</strong> 이벤트를 검사한다.</li>\n<li>이 때, <strong>capture 속성의 이벤트 핸들러가 있다면 실행 시키면서 이벤트 요소로 접근</strong>한다.</li>\n</ul>\n<p><img src=\"https://www.w3.org/TR/DOM-Level-3-Events/images/eventflow.svg\" alt=\"W3C 이벤트 전파 과정\"></p>\n<p><code class=\"language-text\">td</code> 클릭하며 이벤트는 조상을 통해 엘리먼트로 내려간다(capturing). 그러다가 target에 도착하고 다시 올라간다(bubbling).</p>\n<p>capturing은 거의 사용되지 않는다.</p>\n<blockquote>\n<p>보통 기본 이벤트 핸들러는 버블 속성이며 W3C 표준에서 이벤트를 묶을 때 캡처 핸들러인지 버블 핸들러인지 지정할 수 있다. 하지만 IE는 캡처 이벤트를 지원하지 않는다.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">EventTarget<span class=\"token punctuation\">.</span><span class=\"token function\">addEventListener</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">,</span> listner<span class=\"token punctuation\">[</span><span class=\"token punctuation\">,</span> userCapture<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>type : event type을 나타내는 문자열</li>\n<li>listener : 특정 타입의 이벤트가 발생시 알림을 받을 객체.</li>\n<li>useCapture\n만약 true라면, capture 사용. capture를 초기화 한 후, 모든 지정된 타입의 이벤트는 DOM tree에서 하위의 어떤 EventTarget에 전달되기 전에 등록된 리스너에게 먼저 전달된다. tree의 상위로 버블링된 이벤트는 capture를 사용하기 위해 지정된 리스너를 동작 시키지 않는다.</li>\n</ul>\n<h2 id=\"참고\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<p><a href=\"https://www.quirksmode.org/js/events_order.html#link4\">quirkmode.org/events_order</a></p>\n<p><a href=\"https://www.w3.org/TR/DOM-Level-3-Events/#event-flow\">W3C event flow</a></p>","frontmatter":{"title":"Event Bubbling","date":"May 21, 2017"}}},"pageContext":{"slug":"/javascript/event-bubbling/","previous":{"fields":{"slug":"/webpack/5-production/"},"frontmatter":{"title":"[나만의 웹팩 만들기] 5. production","category":"webpack"}},"next":{"fields":{"slug":"/javascript/todolist-with-mvc/"},"frontmatter":{"title":"mvc를 이용하여 todolist 만들어보기","category":"javascript"}}}}