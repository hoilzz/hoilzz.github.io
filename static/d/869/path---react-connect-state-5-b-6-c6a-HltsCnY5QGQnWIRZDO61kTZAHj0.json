{"data":{"site":{"siteMetadata":{"title":"hoilzz","author":"hoilzz","siteUrl":"https://hoilzz.github.io","comment":{"disqusShortName":"","utterances":"hoilzz/hoilzz-blog"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"5e76f7e1-7027-50fd-ad5d-5f17f538756f","excerpt":"react-redux와 connect https://react-redux.js.org/using-react-redux/connect-mapstate 를 번역한 글이다. Connect: mapStateToProps로 데이터 가져오기 는 스토어에서 데이터의 부분을 선택하여 사용한다. 즉, 연결된 컴포넌트가 필요한 데이터만 스토어에서 가져온다. 이것은 스토어 상태가 변할 때마다 호출된다. 전체 스토어 상태를 받고 이 컴포넌트가 필요한 데이터 객체만 가져와야한다. mapStateToProps and…","html":"<h2 id=\"react-redux와-connect\"><a href=\"#react-redux%EC%99%80-connect\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>react-redux와 connect</h2>\n<p><a href=\"https://react-redux.js.org/using-react-redux/connect-mapstate\">https://react-redux.js.org/using-react-redux/connect-mapstate</a>를 번역한 글이다.</p>\n<h2 id=\"connect-mapstatetoprops로-데이터-가져오기\"><a href=\"#connect-mapstatetoprops%EB%A1%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B0%80%EC%A0%B8%EC%98%A4%EA%B8%B0\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Connect: mapStateToProps로 데이터 가져오기</h2>\n<p><code class=\"language-text\">mapStateToProps</code>는 스토어에서 데이터의 부분을 선택하여 사용한다. 즉, 연결된 컴포넌트가 필요한 데이터만 스토어에서 가져온다.</p>\n<ul>\n<li>이것은 스토어 상태가 변할 때마다 호출된다.</li>\n<li>전체 스토어 상태를 받고 이 컴포넌트가 필요한 데이터 객체만 가져와야한다.</li>\n</ul>\n<h3 id=\"mapstatetoprops-and-performance\"><a href=\"#mapstatetoprops-and-performance\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>mapStateToProps and Performance</h3>\n<p><strong>반환 값은 컴포넌트가 리렌더할지 결정한다.</strong></p>\n<p>React Redux는 <code class=\"language-text\">shouldComponentUpdate(SCU)</code>를 내부적으로 구현하여, 컴포넌트가 필요한 데이터가 변경 될 때 wrapper component가 리렌더링되도록 한다. 기본적으로, React Redux는 <code class=\"language-text\">mapStateToProps</code>에서 리턴 받은 객체의 내용이 달라졌는지 판단하기 위해 리턴된 객체의 각 필드에 <code class=\"language-text\">===</code> 비교(shallow equality)를 이용한다. 만약 필드가 하나라도 변경되면, 컴포넌트가 리렌더링되고 update된 prop을 전달받을 수 있다. <strong>동일한 참조 값의 변경된 오브젝트를 리턴하는 것은 컴포넌트가 예상대로 리렌더링 되지 않는 일반적인 실수다.</strong></p>\n<blockquote>\n<p>요 부분이 궁금해서 코드를 찾아봤다.\ndan이 약식으로 <a href=\"https://gist.github.com/gaearon/%0A1d19088790e70ac32ea636c025ba424e\">작성한 코드를 참고</a>하자.\n요약하자면,</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// areStateEqual에 전달되는 값.</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">strictEqual</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> a <span class=\"token operator\">===</span> b\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">pureFinalPropsSelectorFactory</span><span class=\"token punctuation\">(</span>\n  mapStateToProps<span class=\"token punctuation\">,</span>\n  mapDispatchToProps<span class=\"token punctuation\">,</span>\n  mergeProps<span class=\"token punctuation\">,</span>\n  dispatch<span class=\"token punctuation\">,</span>\n  <span class=\"token comment\">// areStatesEqual은 strictEqual을 전달받음.</span>\n  <span class=\"token punctuation\">{</span> areStatesEqual<span class=\"token punctuation\">,</span> areOwnPropsEqual<span class=\"token punctuation\">,</span> areStatePropsEqual <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">let</span> hasRunAtLeastOnce <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span>\n  <span class=\"token keyword\">let</span> state\n  <span class=\"token keyword\">let</span> ownProps\n  <span class=\"token keyword\">let</span> stateProps\n  <span class=\"token keyword\">let</span> dispatchProps\n  <span class=\"token keyword\">let</span> mergedProps\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">handleNewPropsAndNewState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    stateProps <span class=\"token operator\">=</span> <span class=\"token function\">mapStateToProps</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> ownProps<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>mapDispatchToProps<span class=\"token punctuation\">.</span>dependsOnOwnProps<span class=\"token punctuation\">)</span>\n      dispatchProps <span class=\"token operator\">=</span> <span class=\"token function\">mapDispatchToProps</span><span class=\"token punctuation\">(</span>dispatch<span class=\"token punctuation\">,</span> ownProps<span class=\"token punctuation\">)</span>\n\n    mergedProps <span class=\"token operator\">=</span> <span class=\"token function\">mergeProps</span><span class=\"token punctuation\">(</span>stateProps<span class=\"token punctuation\">,</span> dispatchProps<span class=\"token punctuation\">,</span> ownProps<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> mergedProps\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">handleNewState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> nextStateProps <span class=\"token operator\">=</span> <span class=\"token function\">mapStateToProps</span><span class=\"token punctuation\">(</span>state<span class=\"token punctuation\">,</span> ownProps<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">const</span> statePropsChanged <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token function\">areStatePropsEqual</span><span class=\"token punctuation\">(</span>nextStateProps<span class=\"token punctuation\">,</span> stateProps<span class=\"token punctuation\">)</span>\n    stateProps <span class=\"token operator\">=</span> nextStateProps\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>statePropsChanged<span class=\"token punctuation\">)</span>\n      mergedProps <span class=\"token operator\">=</span> <span class=\"token function\">mergeProps</span><span class=\"token punctuation\">(</span>stateProps<span class=\"token punctuation\">,</span> dispatchProps<span class=\"token punctuation\">,</span> ownProps<span class=\"token punctuation\">)</span>\n\n    <span class=\"token keyword\">return</span> mergedProps\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// ...</span>\n\n  <span class=\"token comment\">// TODO: Add more comments</span>\n\n  <span class=\"token comment\">// If pure is true, the selector returned by selectorFactory will memoize its results,</span>\n  <span class=\"token comment\">// allowing connectAdvanced's shouldComponentUpdate to return false if final</span>\n  <span class=\"token comment\">// props have not changed. If false, the selector will always return a new</span>\n  <span class=\"token comment\">// object and shouldComponentUpdate will always return true.</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">handleSubsequentCalls</span><span class=\"token punctuation\">(</span>nextState<span class=\"token punctuation\">,</span> nextOwnProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> propsChanged <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token function\">areOwnPropsEqual</span><span class=\"token punctuation\">(</span>nextOwnProps<span class=\"token punctuation\">,</span> ownProps<span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// state는 클로저 환경에서 생성된 자유변수</span>\n    <span class=\"token keyword\">const</span> stateChanged <span class=\"token operator\">=</span> <span class=\"token operator\">!</span><span class=\"token function\">areStatesEqual</span><span class=\"token punctuation\">(</span>nextState<span class=\"token punctuation\">,</span> state<span class=\"token punctuation\">)</span>\n    state <span class=\"token operator\">=</span> nextState\n    ownProps <span class=\"token operator\">=</span> nextOwnProps\n\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>propsChanged <span class=\"token operator\">&amp;&amp;</span> stateChanged<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token function\">handleNewPropsAndNewState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>propsChanged<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token function\">handleNewProps</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>stateChanged<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token function\">handleNewState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> mergedProps\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span> <span class=\"token function\">pureFinalPropsSelector</span><span class=\"token punctuation\">(</span>nextState<span class=\"token punctuation\">,</span> nextOwnProps<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> hasRunAtLeastOnce\n      <span class=\"token operator\">?</span> <span class=\"token function\">handleSubsequentCalls</span><span class=\"token punctuation\">(</span>nextState<span class=\"token punctuation\">,</span> nextOwnProps<span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">:</span> <span class=\"token function\">handleFirstCall</span><span class=\"token punctuation\">(</span>nextState<span class=\"token punctuation\">,</span> nextOwnProps<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">connect</code>로 래핑된 컴포넌트의 행동을 요약하자면,</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th align=\"center\">state => stateProps</th>\n<th align=\"center\">(state, ownProps) => stateProps</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">mapStateToProps가 실행될 떄:</td>\n<td align=\"center\">store <code class=\"language-text\">state</code>가 변경될 때</td>\n<td align=\"center\">store <code class=\"language-text\">state</code>가 변경되거나 <code class=\"language-text\">ownProps</code>의 필드가 하나라도 달라지면</td>\n</tr>\n<tr>\n<td align=\"center\">component가 리렌더링 될 때</td>\n<td align=\"center\"><code class=\"language-text\">stateProps</code>의 필드가 하나라도 달라지면</td>\n<td align=\"center\"><code class=\"language-text\">stateProps</code>의 필드가 하나라도 달라지거나 <code class=\"language-text\">ownProps</code>의 필드가 하나라도 달라지면</td>\n</tr>\n</tbody>\n</table>\n<h1 id=\"\"><a href=\"#\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p><strong>only Return New Object References If Needed</strong></p>\n<p>React-Redux는 <code class=\"language-text\">mapStateToProps</code>의 결과값의 변경여부를 체크하기 위해 shallow compare를 한다. 새로운 객체 혹은 새로운 배열 참조 값을 매번 리턴하는 것과 같은 실수는 하기 쉽다. (그리고 이것은 데이터가 실제로 같더라도 리렌더링을 유발한다.)</p>\n<p>new object or array reference를 생성하는 일반적인 동작들</p>\n<ul>\n<li><code class=\"language-text\">.map()</code>, <code class=\"language-text\">.filter()</code>로 새로운 배열 만들기</li>\n<li>.concat으로 배열 합치기</li>\n<li>.slice로 부분적 배열 선택하기</li>\n<li>.assign으로 값 복사하기</li>\n<li>spread oeprator {…oldState, …newDate}로 값 복사하기</li>\n</ul>\n<p>만약 input value가 변경된 경우에만 실행하도록 해주는 memoized selector 함수를 이용하자. value가 변경되지 않으면 <code class=\"language-text\">mapStateToProps</code>는 여전히 동일한 결과 값을 리턴할 거고 <code class=\"language-text\">connect</code>는 re-render를 스킵할 거다.</p>\n<p><strong>Only Perform Expensive Operations When Data Changes</strong></p>\n<p>데이터 변경(transformation)하는 것은 비용이 높다. (보통 새로운 객체 참조값을 리턴하는 경우) <code class=\"language-text\">mapStateToProps</code> 함수가 가능한 빨라지기 위해, 관련 데이터가 변경된 경우에만 복잡한 transformation을 재실행해야 한다.</p>\n<p>이러한 접근에 몇가지 방법이 있다.</p>\n<ul>\n<li>몇몇 transformation은 action creator나 reducer에서 계산되어야 한다. transformed data는 스토어에 유지되어야 한다.</li>\n<li><code class=\"language-text\">render</code> 메서드에서 transformation이 되어야한다.</li>\n<li>만약 transformation이 <code class=\"language-text\">mapStateToProps</code> 함수에서 해야한다면, 값이 변경될 때만 transformation 하기 위해 memoized selector function 이용하기를 권장한다.</li>\n</ul>\n<h2 id=\"behavior-and-gotchas\"><a href=\"#behavior-and-gotchas\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Behavior and Gotchas</h2>\n<p><strong>mapStateToProps는 Store state가 동일하다면 실행되지 않는다</strong></p>\n<p><code class=\"language-text\">connect</code>로 생성된 wrapper component는 Redux store를 구독한다. action이 dispatch 될 때마다, <code class=\"language-text\">store.getState()</code>를 호출하고 <code class=\"language-text\">lastState === currentState</code>인지 확인한다. 만약 2개의 state 참조 값이 같다면 <code class=\"language-text\">mapStateToProps</code> 함수를 재실행 하지 않는다. 왜냐하면 store state의 나머지도 변경되지 않았을거라고 판단하기 때문이다.</p>\n<p><code class=\"language-text\">combineReducer</code> utility 함수는 이것을 최적화하려고 한다. 만약 reducer 조각이 new value를 반환하지 않는다면, combineReducers는 새 object 대신에 old state object를 리턴한다. 이것은 reducer에서 변경이 root state object가 업데이트 되지 않도록 할 수 있다. 그래서 UI는 리렌더링 되지 않는다.</p>\n<h2 id=\"내가-궁금했었던거\"><a href=\"#%EB%82%B4%EA%B0%80-%EA%B6%81%EA%B8%88%ED%96%88%EC%97%88%EB%8D%98%EA%B1%B0\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>내가 궁금했었던거</h2>\n<p>Q. react-redux의 connect에서 퍼포먼스 최적화를 해준다고 했는데 뭘까?\nA. SCU를 내부적으로 구현했다. connect된 컴포넌트에서 리렌더링이 되는 과정을 간단히 살펴보자.</p>\n<ul>\n<li>state 변경 -> mapStateToProps 실행 -></li>\n</ul>\n<h2 id=\"summary\"><a href=\"#summary\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h2>\n<p>react-redux는 SCU를 내부적으로 구현</p>\n<ul>\n<li>컴포넌트가 필요한 데이터가 변경 될 때 리렌더링 일으킴</li>\n<li>\n<p>mapStateToProps에서 데이터 변경 유무를 판단하는 방법</p>\n<ul>\n<li>리턴된 객체의 각 필드에 대해 <code class=\"language-text\">===</code> 으로 shallow equality 비교</li>\n<li>여기서 필드가 하나라도 변경되면 리렌더링</li>\n</ul>\n</li>\n</ul>\n<p><strong>퍼포먼스</strong></p>\n<ul>\n<li>\n<p>동일한 input 값이더라도 .map, .filter .assign 등과 같이 새로운 참조 값을 리턴하는 것은 mapStateToProps가 shallow compare시 값이 달라졌다고 판단</p>\n<ul>\n<li>불필요한 리렌더링 유발</li>\n</ul>\n</li>\n<li>\n<p>memoized selector 함수를 이용하여 해결</p>\n</li>\n<li>\n<p>transformation은 mapStateToProps에서 하지 않는 것을 권장</p>\n<ul>\n<li>해당 연산의 input 값이 안바뀌더라도, state가 변경될 때마다 매번 불필요한 연산을 필요로함.</li>\n</ul>\n</li>\n<li>\n<p>해결책</p>\n<ul>\n<li>action creator나 reducer에서 연산하여 store에 유지</li>\n<li>굳이 mapStateToProps에서 해야한다면 memoized</li>\n</ul>\n</li>\n<li>\n<p><code class=\"language-text\">lastState === curentState</code>를 확인하여 mapStateToProps 실행 여부 판단.</p>\n</li>\n<li>\n<p>mapStateToProps가 실행되야 한다면 실행 후에, 리턴된 객체에 대해 <code class=\"language-text\">===</code>으로 shallow equality 비교하여 리렌더링 판단.</p>\n</li>\n</ul>","frontmatter":{"title":"connect의 mapStateToProps는 언제 실행될까. 그리고 리렌더링은 언제 어떻게 발생하는가.","date":"March 24, 2019"}}},"pageContext":{"slug":"/react/connect-state/","previous":{"fields":{"slug":"/devlog/react-render/"},"frontmatter":{"title":"stateless component, purecomponent 리렌더링 이유 비교","category":"devlog"}},"next":null}}