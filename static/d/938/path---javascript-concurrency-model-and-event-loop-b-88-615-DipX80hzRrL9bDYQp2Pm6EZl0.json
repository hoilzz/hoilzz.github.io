{"data":{"site":{"siteMetadata":{"title":"hoilzz","author":"hoilzz","siteUrl":"","comment":{"disqusShortName":"","utterances":"hoilzz/hoilzz.github.io"},"sponsor":{"buyMeACoffeeId":""}}},"markdownRemark":{"id":"801b12e3-05e7-5960-a6a7-a5e06c291ef4","excerpt":"Javascript는 싱글 스레드로 동작한다. node.js는 이벤트 루프 기반 싱글 스레드다 등등 이런 말을 많이 들었다. 싱글 스레드는 동시에 하나의 작업만 처리 가능하다.\n하지만 js가 실행되는 환경에서는 많은 작업이 동시에 처리되고 있다. 정답은 동시성(Concurrency) 모델과 이벤트 루프에 있다.\nJS는 이벤트 루프를 통해 비동기 방식으로 동시성을 지원한다. 사실 무슨말인지 이해하기 힘들다. 먼저, JS가 동작하는 환경과 엔진을 살펴보자. JS 엔진은 JS…","html":"<ul>\n<li><em>Javascript는 싱글 스레드로 동작한다.</em></li>\n<li><em>node.js는 이벤트 루프 기반 싱글 스레드다</em></li>\n</ul>\n<p>등등 이런 말을 많이 들었다.</p>\n<p>싱글 스레드는 동시에 하나의 작업만 처리 가능하다.\n하지만 js가 실행되는 환경에서는 많은 작업이 동시에 처리되고 있다.</p>\n<p>정답은 동시성(Concurrency) 모델과 이벤트 루프에 있다.\nJS는 이벤트 루프를 통해 비동기 방식으로 동시성을 지원한다.</p>\n<p>사실 무슨말인지 이해하기 힘들다. 먼저, JS가 동작하는 환경과 엔진을 살펴보자.</p>\n<p>JS 엔진은 JS로 작성한 코드를 해석하고 실행하는 인터프리터다. 주로 웹 브라우저에서 이용된다.</p>\n<p>JS엔진은 3가지 영역을 가진다.</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6be049966a74b4e1f13cc072f6d5e072/2b75f/concurrency_model_1.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 53.76532399299475%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsSAAALEgHS3X78AAACOElEQVQoz42T208TURCH9w/1XfFBExJ9MDHKRZFLUNpSEK2Fre1CW0BTKHeKQGmhxiBYSltotEjbiDGQAL3sdj8OBxrB8OAkX2b2nMlvZ2ZnFb2qU6lWBDV/BUOnrBs3UhGYpsm5nftarIxl53mTHMKZ8uNI+nBs+3iX9OPc8aJ+maM7EKN7PIotEKV77AKriNX5dXSjein4V1QZyozTsfEWW/I99l2PxJJQebXlwBYJ8Exb4oV/iY6Pq7R/iNI+GqFJCwnhVdGBIQWNSy8r9GaCWLYHaJ7v4oG3gXr3Y1pXerCnVeyRMdr9UZ44A9xptFL/UuWhVaPFt0hPcE1WaFar5HI5Dg8Prws2znRyf+CRpHXFfkUwQqNrgrpmG7cbLNQ12WjxL9IbXBWCBpubG8TjcVKpFIVCAWVQtNy24cCacmPPDEq6tlx0xsXZyjjN7mWe+8Ki3c+SttE1GjyfxEzXKFd0wuEwmqZJ8vk8ysTeNM60CzXtYUCI9otZunZFQnYQ99cgfZNL9E0v8HoyJOmbWqBHeG1RzFDXZbuJRIJYLCbbVgqlED9OvWRPhwV+fpZGSP/RWN9zyufvxz5x7ydbrDEs8/eLQUwM+YUPDg44Ojq6mOF+cYKdEyeZExe7xyrZiofIThdPO2/RO3QPi3qX0LcOsmW3vJd5J/3iZSNUTZ1/TfldjpErTpEvzUpyxVkK5TkZ75/OSM7P5H2xljPNr9KyqE6sy5UdlHvITWby32ZiXvtTzgDrafPhSG0QvwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"concurrency model 1\"\n        title=\"\"\n        src=\"/static/6be049966a74b4e1f13cc072f6d5e072/40fad/concurrency_model_1.png\"\n        srcset=\"/static/6be049966a74b4e1f13cc072f6d5e072/707e9/concurrency_model_1.png 148w,\n/static/6be049966a74b4e1f13cc072f6d5e072/649e0/concurrency_model_1.png 295w,\n/static/6be049966a74b4e1f13cc072f6d5e072/40fad/concurrency_model_1.png 590w,\n/static/6be049966a74b4e1f13cc072f6d5e072/b3fef/concurrency_model_1.png 885w,\n/static/6be049966a74b4e1f13cc072f6d5e072/2b75f/concurrency_model_1.png 1142w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n  </span>\n  </a></p>\n<h2 id=\"call-stack-aka-run-to-completion\"><a href=\"#call-stack-aka-run-to-completion\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Call Stack (a.k.a. run to completion)</h2>\n<p>JS는 단 하나의 호출 stack을 사용한다. (그래서 Run To Completion)\n1개 함수가 실행되면 call stack에 push되어 다른 함수는 실행되지 못한다.\n실행이 끝나면 pop이 되고 다음 함수가 실행된다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">test1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"test1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">test2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">test1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"test2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">test2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/45bd2c7eb46ad9a488b6f32ebb214163/c9681/concurrency_model_5.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 72.07285342584562%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAACoklEQVQ4y5VSyVITURTNl2rBRlBEIeDAIJKAQhIhZWVAQFgQQBlUQKoMpsmc7s5AhwykYKGkkzCEQROIbqSO9z1IXFiWxducW+ede+55t1vj3pfQF7fCnJ7kGDiIInS4wevh1CT64zZ498MQi0pNp1Ms8B1EEC5uQk+1mXTPNu34lPdB4ycDU3Ic9sw0R9Yok7DKvSAMHsYQOUrUOENilA+NHaeoHuPcUGoCQiHEDCMwJsdgyzj4pUhCuRiHkWrrloNj8CCGMBlWdYOJV3wIM2Q149hgVyH4b0NTapxzDFnz9QwTVcNRMlQgHcYxoIzAkp7iyPZ6LUPD1fOYoXSkIJiPovltN1odT9A81w13VkTkOMnvmW5w8z+G7FkjOzMcuWEhhvsLPdBO96Bl8Sk8ZBg9SV7qtmdgSI1dfpSj5N+GblXEg4/96F4xoG1FD38+gtBeDNoPOnQR1/quF96cDHFfqelal3Wci52kMEBpWWpT1XA9G0LTbCcabW1onHoEXy7MDe9Md6DR3o7bjsfwqBJClLppphMNpGuYekipJWycpGFIjsK+Tb9NegKuPTL05CR0CUYM+G0cA4UIpdlAp8uI58Qx9OXDkChhl2Diug6XgXPRYgI68SWGoq/RL1uxpvqhEXaDqLff45Pr7M3wqjLfYZ3tiiN074o8YR3p2EtuWu/yhFJBwQ1LE25ZtKgn3eqOQIbZIN+d3mmGdol2k5cpZRRty3ronMMc2Z7ZGljNdC1LvWAvY6m1tE/9mhntK31Y/bIOzfnFDwQyEt44F+BJBnH2q4IKcaHtMGad83An/GCac+IDGRnzwnsIcS/nKhc/4d8SMfd5kXoDKF9UoAGd8mkJ6tcszr6XUT3lb2XkdlWU6O4PV+Icw+op8V611vsb9o133zhXE1gAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"concurrency model 2\"\n        title=\"\"\n        src=\"/static/45bd2c7eb46ad9a488b6f32ebb214163/40fad/concurrency_model_5.png\"\n        srcset=\"/static/45bd2c7eb46ad9a488b6f32ebb214163/707e9/concurrency_model_5.png 148w,\n/static/45bd2c7eb46ad9a488b6f32ebb214163/649e0/concurrency_model_5.png 295w,\n/static/45bd2c7eb46ad9a488b6f32ebb214163/40fad/concurrency_model_5.png 590w,\n/static/45bd2c7eb46ad9a488b6f32ebb214163/b3fef/concurrency_model_5.png 885w,\n/static/45bd2c7eb46ad9a488b6f32ebb214163/c9681/concurrency_model_5.png 1153w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n  </span>\n  </a></p>\n<ol>\n<li>먼저, 전역 환경에 대한 코드 블록이 먼저 스택에 쌓인다.</li>\n<li>전역 환경은 가상의 익명함수로 감싸져 있다고 생각하자.</li>\n<li>그래서, 마지막 라인까지 실행되어야 스택에서 제거 된다.</li>\n<li><code class=\"language-text\">test2()</code>라인을 만나고 <code class=\"language-text\">test2</code> 함수에 대한 코드 블록이 쌓인다.</li>\n<li>그 다음에는 <code class=\"language-text\">test1()</code>에 대한 코드 블록이 형성된다.</li>\n<li><code class=\"language-text\">test1()</code>에서 <code class=\"language-text\">&quot;test1&quot;</code>을 출력 후 함수 종료와 함께 스택에서 제거된다.</li>\n<li><code class=\"language-text\">test2()</code>로 돌아와서 <code class=\"language-text\">&quot;test2&quot;</code>를 출력 후 함수 종료와 함께 스택에서 제거된다.</li>\n<li>모든 전역환경에 대한 코드를 수행하였으므로 익명 함수도 제거된다.</li>\n</ol>\n<h2 id=\"heap\"><a href=\"#heap\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Heap</h2>\n<p>인스턴스와 같은 동적으로 생성된 객체가 Heap에 할당된다.</p>\n<h2 id=\"task-queue\"><a href=\"#task-queue\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Task Queue</h2>\n<p>Queue는 JS 런타임 환경에서 처리해야 하는 Task들을 임시 저장한다.\n저장된 Task들은 <code class=\"language-text\">Call Stack</code>이 비었을 때 Queue의 Task를 순서대로 수행한다.</p>\n<p><em>누가 Queue의 task들을 Call Stack에 추가할까?</em></p>\n<p><code class=\"language-text\">Event Loop</code>가 큐에 대기 중인 첫번째 태스크를 추가한다.</p>\n<p><em>그럼 어떤 task가 저장될까?</em></p>\n<p>비동기로 호출되는 함수들은 Task Queue에 쌓인다. 예륻 들어 이벤트에 의해 실행되는 함수(handler)들이 비동기로 실행된다. 또한, JS 엔진이 나닌 Web API영역에 따로 정의되어 있는 함수들(ajax, timer, DOM Events)의 콜백 함수들이 비동기로 실행된다.</p>\n<p>위 예제에 몇가지를 더 추가해보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">test1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"test1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">test2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\t<span class=\"token function\">test1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"test2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">delay</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">var</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span> i<span class=\"token operator\">&lt;</span><span class=\"token number\">1000000</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">asyncFunc</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\tconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"asyncFunc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>asyncFunc<span class=\"token punctuation\">,</span> <span class=\"token number\">10</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token function\">test2</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Call Stack에는 전역환경의 코드 순서대로 setTimeout - test2() 쌓인다.\n하지만 출력 순서는 위와 같지 않다. 즉, <code class=\"language-text\">asyncFunc</code>가 백만번 도는 for문보다 먼저 실행되지 않는다. 즉, 10ms가 지나도 <code class=\"language-text\">test2</code>에서 <code class=\"language-text\">test1</code>을 실행하기 전까지는 <code class=\"language-text\">asyncFunc</code>가 절대 실행되지 않는다.</p>\n<p>그러므로 위 예제는 <code class=\"language-text\">&quot;asyncFunc&quot;</code>가 가장 마지막에 출력된다.</p>\n<p>그림으로 다시 이해해보자.</p>\n<p><a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6f2f338e95f1c303f66499bbe823c675/434dd/concurrency_model_4.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 71.29391602399315%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsSAAALEgHS3X78AAAC0klEQVQ4y5WT60+SYRiH+Udt+sVlptkkNUtLK8VUXjVE4ywgB1ERAY/TeZqKmBoIiIiaeehD64u15VZePe8zDx9qbX5gvLu4f9f9e553aJLfsgwdTBA5miX0aZqJ4wUWv8QJHk4RFmxEsJmTZebOYvL5ms2frTF1vCgzKlPnN76m0MyervDmoxFl205r0owx0483H6YlYRLMxtuEGWt2AOdeUDzfMvfeCL07HplRmS7xnvHP82gWxKa2pEWI3HSl+rCIcOBgnA6xoDvtpjPlwJkL4stH6EjdMv9+FNtuQGa6RVaVTp8soVGrq1sMaZcIODBn/QwcjKEXA4a0Uzbvyw3L1opkLrnMtx+RzdWMyvTbVnkF/xQGhLAjLdpkXHSmHfK4njsJE+abQVXoz0fRxXtQNm20xHux7wzi3b9jw+6rhpbdAfozISp89dzv0VLufk7vRj++w+itMPVfYUw2VC9WCkVDz84oNeEmakM6qkebMG158B1E0CetGMQ1KEmbuFMhFC/lL+HcySqPAvVovQ1UeOpQVq34cmGeBF9TFXiFdrAR00cvju1BtEONaP0NVInfnOlhbLmAPL4h5aQ9eS08jVHirKbUVE1xbyX6ZbMQRqgU4VJLDRXe+hvhY/8LydQlqtC+N0hXpg9jth9FvMSpk6uG1WPNNEwqPIu20LXukMKacDMvJ/U8Fd/mhI++1NANq43qcO+MYNx0UTfZJlnddBsTRwvin3K8QmFPOUX6hxS0l6Cb68aTDVH4roxCwe4ppRg/uLBs+ijQl1CklFFkKJcN25dMgj2Qc8VWLWOHc2iWztZpXTPRsyVqr1mxbg8wvD+JErcK5kYfs+DOjuDPRemI225YID+OPS2OvG6X2bY1MzPHy2h+c8nu0R7BsRDTizOcX3xHZYlsEn8owMrGKj8vL+RnZTPGUCTIRnqLX2Lq/OIH87FFhqNBUvmMSMEfD1RZ8r+4H5AAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    ></span>\n    <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;box-shadow:inset 0px 0px 0px 400px white;\"\n        alt=\"concurrency model 4\"\n        title=\"\"\n        src=\"/static/6f2f338e95f1c303f66499bbe823c675/40fad/concurrency_model_4.png\"\n        srcset=\"/static/6f2f338e95f1c303f66499bbe823c675/707e9/concurrency_model_4.png 148w,\n/static/6f2f338e95f1c303f66499bbe823c675/649e0/concurrency_model_4.png 295w,\n/static/6f2f338e95f1c303f66499bbe823c675/40fad/concurrency_model_4.png 590w,\n/static/6f2f338e95f1c303f66499bbe823c675/b3fef/concurrency_model_4.png 885w,\n/static/6f2f338e95f1c303f66499bbe823c675/434dd/concurrency_model_4.png 1167w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n  </span>\n  </a></p>\n<p>근데 여기서 궁금한 점은</p>\n<ul>\n<li>이벤트 루프가 현재 실행 중인 태스크가 있는지 없는지 어떻게 <strong>실시간으로</strong> 확인하는가?</li>\n</ul>\n<p>MDN의 이벤트 루프에 관한 글에 첨부된 가상의 코드를 보자.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span>queue<span class=\"token punctuation\">.</span><span class=\"token function\">waitForMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\tqueue<span class=\"token punctuation\">.</span><span class=\"token function\">processNextMessage</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">waitForMessage()</code> 는 큐가 비어있을 때 태스크가 큐에 추가될 때까지 대기한다.\nwhile문을 통해 태스크가 추가될 때까지 계속 반복한다.</p>\n<p>이 때, 비동기 API들의 작업이 완료 되어 태스크가 추가되면\n이벤트 루프는 콜 스택이 비었을 때, 태스크 큐의 첫번째 태스크를 Call Stack으로 가져와 가져와 실행한다. (이 때, 이벤트 큐에 대기하는 이벤트들은 <strong>한 번에 하나씩</strong> Call Stack으로 호출되어 처리된다.)</p>\n<h2 id=\"summary\"><a href=\"#summary\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Summary</h2>\n<ul>\n<li>JS 엔진이 단일 Call Stack을 사용한다는 점에서 <code class=\"language-text\">싱글 스레드</code>로 동작한다는 말은 맞다.</li>\n<li>하지만 <code class=\"language-text\">Event Loop</code>를 이용하여 비동기 방식으로 동시성(Concurrency)을 지원한다.</li>\n<li>\n<p>Web API의 timer, ajax, DOM Events 등이 가진 콜백 함수들은 비동기로 실행된다. 태스크 큐는 콜백 함수들이 대기하는 큐다.</p>\n<ul>\n<li>이 때, Event Loop는 Call Stack이 비워질 때 큐에서 콜백 함수를 FIFO로 꺼내와서 Call Stack에서 처리한다.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"참고\"><a href=\"#%EC%B0%B8%EA%B3%A0\" aria-hidden class=\"anchor\"><svg aria-hidden=\"true\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고</h2>\n<p><a href=\"http://meetup.toast.com/posts/89\">자바스크립트와 이벤트 루프 nhn ent.</a></p>\n<p><a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management\">Concurrency model and Event Loop from mdn</a></p>","frontmatter":{"title":"concurrency model and event loop","date":"August 01, 2017"}}},"pageContext":{"slug":"/javascript/concurrency-model-and-event-loop/","previous":{"fields":{"slug":"/javascript/todolist-with-mvc/"},"frontmatter":{"title":"mvc를 이용하여 todolist 만들어보기","category":"javascript"}},"next":{"fields":{"slug":"/webpack/0-webpack/"},"frontmatter":{"title":"[나만의 웹팩 만들기] 0. webpack 개념","category":"webpack"}}}}